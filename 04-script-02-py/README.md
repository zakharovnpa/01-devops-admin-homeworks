## Домашнее задание к занятию "4.2. Использование Python для решения типовых DevOps задач"

### Обязательные задания

#### 1. Есть скрипт:
```python
    #!/usr/bin/env python3
	a = 1
	b = '2'
	c = a + b
```
   * Какое значение будет присвоено переменной c?
   * Как получить для переменной c значение 12?
   * Как получить для переменной c значение 3?
	
   **Ответ:**
   
   * в первом случае при арифметическом действии сложения мы получим сообщение об ошибке о неподдерживаемом операнде "+" для сложения двух разных типов переменныхт 'int' (целое число) и 'str' (строка)
   ```bash
   >>> a = 1
   >>> 
   >>> b = '2'
   >>> 
   >>> c = a + b
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   TypeError: unsupported operand type(s) for +: 'int' and 'str'

   ```
   * во втором случае необходимо получить не число 12, а рядом стоящие знаки ` 1 ` и ` 2 `. Для этого во время арифметического действия сложения приведем переменную ` a ` к строчному типу 'str': 
   
   ```bash
   >>> type(a)
   <class 'int'>
   >>> 
   >>> type(b)
   <class 'str'>
   >>> 
   >>> c = str(a) + b
   >>> 
   >>> c
   '12'
   
   ```
   * в третьем случае для получения арифметической сцммы числел 1 и 2 необходимо привести значеие переменной ` b ` к типу целго числа 'int'
   ```bash
   >>> type(a)
  <class 'int'>
  >>> 
  >>> type(b)
  <class 'str'>
  >>> 
  >>> c = a + int(b)
  >>> 
  >>> c
  3
  >>> 
  >>> 

   ```
   

#### 2. Мы устроились на работу в компанию, где раньше уже был DevOps Engineer. Он написал скрипт, позволяющий узнать, какие файлы модифицированы в репозитории, относительно локальных изменений. Этим скриптом недовольно начальство, потому что в его выводе есть не все изменённые файлы, а также непонятен полный путь к директории, где они находятся. Как можно доработать скрипт ниже, чтобы он исполнял требования вашего руководителя?

```python
    #!/usr/bin/env python3

    import os

	bash_command = ["cd ~/netology/sysadm-homeworks", "git status"]
	result_os = os.popen(' && '.join(bash_command)).read()
    is_change = False
	for result in result_os.split('\n'):
        if result.find('modified') != -1:
            prepare_result = result.replace('\tmodified:   ', '')
            print(prepare_result)
            break

```
   **Ответ:**
   
Изменения в скрипте:
- удалена переменная ` is_change `. В скрипте ей присвоено значение ` False `, а сама переменная больше нигде не участвует.
- удалена команда ` breake ` которая прерывает обработку скрипта при первом же найденом вхождении
- добавлен в вывод результатов путь до директории, где запускается команда ` git status `
- удалены лишние пробелы

* Измененный скрипт ` test-3-ex-2.py `
```python
#!/usr/bin/env python3

import os
    
bashCommand = ["cd ~/netology-project/virt-homeworks-1", "git status"]
result_os = os.popen(' && '.join(bashCommand)).read()

for result in result_os.split('\n'):
    if result.find('изменено') != -1:
    
#is_change = False	#удалили неработающую переменную

        prepare_result = result.replace('\tизменено:   ', '')
        prepare_result = result.replace('\tизменено:', '/root/netology-project/virt-homeworks-1/')  #внесли путь до директории
        prepare_result = prepare_result.replace(' ', '')	#удаляем лишние пробелы
        print(prepare_result)
	
# break		#удалили останавливающую цикл команду

```
* Результат выполнения скрипта  ` test-3-ex-2.py `

```bash
root@PC-Ubuntu:~/scripts# ./test-3-ex-2.py 
/root/netology-project/virt-homeworks-1/05-virt-01-basics/README.md
/root/netology-project/virt-homeworks-1/05-virt-02-iaac/README.md
/root/netology-project/virt-homeworks-1/05-virt-03-docker/README.md
/root/netology-project/virt-homeworks-1/05-virt-04-docker-compose/README.md
/root/netology-project/virt-homeworks-1/05-virt-05-docker-swarm/README.md

```

#### 3. Доработать скрипт выше так, чтобы он мог проверять не только локальный репозиторий в текущей директории, а также умел воспринимать путь к репозиторию, который мы передаём как входной параметр. Мы точно знаем, что начальство коварное и будет проверять работу этого скрипта в директориях, которые не являются локальными репозиториями.

   **Ответ:**
   
 В скрипт добавлена возможность принимать входящие аргументы (модуль ` import sys `)
 * Измененный скрипт ` ex-3.py `
 ```python
 #!/usr/bin/env python3

import os
import sys

cmd = sys.argv[1]
bash_command = ["cd "+cmd, "git status"]
result_os = os.popen(' && '.join(bash_command)).read()
for result in result_os.split('\n'):
    if result.find('изменено') != -1:
        prepare_result = result.replace('\tизменено: ', '')
        print(cmd+prepare_result)

 ```
 * Результат выполнения скрипта  ` ex-3.py `
 ```bash
root@PC-Ubuntu:~/scripts# ./ex-3.py ~/netology-project/virt-homeworks-1
/root/netology-project/virt-homeworks-1     05-virt-01-basics/README.md
/root/netology-project/virt-homeworks-1     05-virt-02-iaac/README.md
/root/netology-project/virt-homeworks-1     05-virt-03-docker/README.md
/root/netology-project/virt-homeworks-1     05-virt-04-docker-compose/README.md
/root/netology-project/virt-homeworks-1     05-virt-05-docker-swarm/README.md
```
* результат работы скрипта в директории, где не активирован Git
```bash
root@PC-Ubuntu:~/scripts# ./ex-3.py ~/netology-project

 Каталог  /root/netology-project не является GIT репозиторием

 ```

#### 4. Наша команда разрабатывает несколько веб-сервисов, доступных по http. Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис. Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков. Мы хотим написать скрипт, который опрашивает веб-сервисы, получает их IP, выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>. Также, должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. Будем считать, что наша разработка реализовала сервисы: drive.google.com, mail.google.com, google.com.

Наша команда разрабатывает несколько веб-сервисов, доступных по http. 
Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис. 

Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков. 

Мы хотим написать скрипт, который:
- опрашивает веб-сервисы, 
- получает их IP, 
- выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>. 
- должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. 

Будем считать, что наша разработка реализовала сервисы: drive.google.com, mail.google.com, google.com.

   **Ответ:**

#### Дополнительное задание (со звездочкой*) - необязательно к выполнению

Так получилось, что мы очень часто вносим правки в конфигурацию своей системы прямо на сервере. Но так как вся наша команда разработки держит файлы конфигурации в github и пользуется gitflow, то нам приходится каждый раз переносить архив с нашими изменениями с сервера на наш локальный компьютер, формировать новую ветку, коммитить в неё изменения, создавать pull request (PR) и только после выполнения Merge мы наконец можем официально подтвердить, что новая конфигурация применена. Мы хотим максимально автоматизировать всю цепочку действий. Для этого нам нужно написать скрипт, который будет в директории с локальным репозиторием обращаться по API к github, создавать PR для вливания текущей выбранной ветки в master с сообщением, которое мы вписываем в первый параметр при обращении к py-файлу (сообщение не может быть пустым). При желании, можно добавить к указанному функционалу создание новой ветки, commit и push в неё изменений конфигурации. С директорией локального репозитория можно делать всё, что угодно. Также, принимаем во внимание, что Merge Conflict у нас отсутствуют и их точно не будет при push, как в свою ветку, так и при слиянии в master. Важно получить конечный результат с созданным PR, в котором применяются наши изменения. 


---

